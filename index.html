<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LB Navigator</title>

  <!-- Apple PWA Icon -->
  <link rel="apple-touch-icon" href="lb-icon.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="LB Navigator" />

  <style>
    body { font-family: Arial, sans-serif; background-color: #f5f5f5; color: #222; margin: 0; padding: 0; }
    header { background-color: #c00; color: white; padding: 1em; text-align: center; display:flex; align-items:center; justify-content:center; font-size: 1.5em; }
    .logo { background:white; color:#c00; font-weight:bold; font-size:1.2em; padding:0.2em 0.6em; margin-right:0.5em; border-radius:2px; }
    main { padding: 1em 2em; }
    input { width: 100%; padding:0.5em; margin:0.2em 0; border-radius:6px; border:1px solid #ccc; box-sizing:border-box; }
    .button-row { display:flex; gap:0.5em; margin-top:0.5em; }
    button { background:#c00; color:white; border:none; padding:0.5em 1em; border-radius:6px; cursor:pointer; flex:1; }
    button:hover { background:#e33; }
    #output { background:white; border-radius:10px; padding:1em; margin-top:1em; box-shadow:0 0 5px rgba(0,0,0,0.2); }
    .route-segment { display:flex; flex-direction:column; margin:0.5em 0; padding:0.5em; border-left:6px solid; border-radius:4px; }
    .segment-line { font-weight:bold; margin-bottom:0.2em; padding:0.2em 0; border-radius:3px; color:white; text-align:center; width:60px; }
    .main-stop { font-weight:bold; }
    .intermediate { color:#999; font-size:0.9em; margin-left:1em; }
    .line-group { margin-bottom:1em; }
    .line-group h4 { margin:0.2em 0; color:#c00; cursor:pointer; user-select:none; }
    .line-group ul { list-style-type:none; padding-left:1em; margin:0; display:none; }
    .line-group.open ul { display:block; }
    textarea { display:none; }

    .route-block { margin-top: 0.8em; padding-top: 0.2em; }
    .route-title { font-weight: bold; margin: 0.3em 0 0.2em; }
    .route-subtitle { color:#666; font-size:0.95em; margin-bottom:0.2em; }
    .divider { height:1px; background:#eee; margin:0.8em 0; }
  </style>
</head>
<body>
  <header>
    <div class="logo">LB</div>
    LB Navigator
  </header>
  <main>
    <h3>LinienÃ¼bersicht:</h3>
    <div id="lineOverview"></div>

    <label>Start:</label>
    <input id="startStation" placeholder="z.B. Soul_Society(HBF)" />
    <label>Ziel:</label>
    <input id="endStation" placeholder="z.B. Puttgarden" />

    <div class="button-row">
      <button onclick="findRoute()">Route finden</button>
      <button onclick="findRoute(true)">Route (min. Umstiege)</button>
    </div>

    <div id="output"></div>

    <textarea id="linesInput">{
      "lines": [
        {
          "id":"RB1",
          "name":"RB1",
          "stops":[
            {"station":"Soul_Society(HBF)","platform":"3"},
            {"station":"LowlightHafen","platform":"1"},
            {"station":"Revon","platform":"1"}
          ]
        },
        {
          "id":"RB3",
          "name":"RB3",
          "stops":[
            {"station":"Soul_Society(HBF)","platform":"1"},
            {"station":"Society Burg","platform":"1"},
            {"station":"Society(NORD)","platform":"1"},
            {"station":"Heringsdorf Neuhof","platform":"1"},
            {"station":"Hamburg","platform":"2"},
            {"station":"Timmendorf(Park)","platform":"1"},
            {"station":"Scharbeutz","platform":"2"},
            {"station":"Puttgarden","platform":"1"},
            {"station":"Roedby","platform":"1"}
          ]
        },
        {
          "id":"M",
          "name":"Metronom",
          "stops":[
            {"station":"Hamburg","platform":"1"},
            {"station":"Soul_Society(SÃ¼d)","platform":"1"},
            {"station":"Soul_Society(HBF)","platform":"2"},
            {"station":"Moislingen","platform":"1"},
            {"station":"Revon","platform":"2"}
          ]
        },
        {
          "id":"RE6",
          "name":"RE6",
          "stops":[
            {"station":"Soul_Society(HBF)","platform":"4"},
            {"station":"Swinoujscie (SwinemÃ¼nde)","platform":"1"}
          ]
        }
      ]
    }</textarea>
  </main>

  <script>
    let network = {};

    // Farbschema: RB = rot, Metronom = gelb, RE6 = lila
    const lineColors = { "RB1":"#c00", "RB3":"#c00", "M":"#ffcc00", "RE6":"#6a00ff" };

    // -------- tolerant input (normalize + alias + fuzzy) --------
    function normalizeName(name){
      return (name || "")
        .toLowerCase()
        .replace(/\s+/g,'')
        .replace(/_/g,'')
        .replace(/[()\-.,]/g,'')
        .replace(/Ã¤/g,'ae').replace(/Ã¶/g,'oe').replace(/Ã¼/g,'ue').replace(/ÃŸ/g,'ss');
    }

    const stationAliases = {
      "soulsociety": "Soul_Society(HBF)",
      "society": "Soul_Society(HBF)",
      "hbf": "Soul_Society(HBF)",

      // Wunsch: timmendorf -> timmendorf(park)
      "timmendorf": "Timmendorf(Park)",
      "timmendorfpark": "Timmendorf(Park)",
      "timmendorferpark": "Timmendorf(Park)",

      // optional kleine Helfer
      "swinemuende": "Swinoujscie (SwinemÃ¼nde)",
      "swinoujscie": "Swinoujscie (SwinemÃ¼nde)"
    };

    function levenshtein(a, b){
      if(a === b) return 0;
      const m = a.length, n = b.length;
      if(m === 0) return n;
      if(n === 0) return m;

      const dp = Array.from({length: m+1}, () => Array(n+1).fill(0));
      for(let i=0;i<=m;i++) dp[i][0]=i;
      for(let j=0;j<=n;j++) dp[0][j]=j;

      for(let i=1;i<=m;i++){
        for(let j=1;j<=n;j++){
          const cost = a[i-1] === b[j-1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i-1][j] + 1,
            dp[i][j-1] + 1,
            dp[i-1][j-1] + cost
          );
        }
      }
      return dp[m][n];
    }

    function findStation(input){
      const n = normalizeName(input);

      // 1) Alias (hart)
      if(stationAliases[n]) return stationAliases[n];

      // 2) Exakt (normalize)
      for(const s in network){
        if(normalizeName(s) === n) return s;
      }

      // 3) Fuzzy best match
      let bestStation = null;
      let bestScore = Infinity;

      for(const s in network){
        const sn = normalizeName(s);
        const d = levenshtein(n, sn);
        if(d < bestScore){
          bestScore = d;
          bestStation = s;
        }
      }

      // Schwelle: kurze Eingaben sollen nicht random matchen
      const maxAllowed = Math.max(1, Math.floor(n.length * 0.25));
      if(bestStation && bestScore <= maxAllowed) return bestStation;

      return null;
    }
    // -----------------------------------------------------------

    function loadLines(){
      const data = JSON.parse(document.getElementById('linesInput').value);

      // Graph mit korrektem from/to Gleis
      network = {};
      for(const line of data.lines){
        for(let i=0;i<line.stops.length;i++){
          const cur = line.stops[i];
          if(!network[cur.station]) network[cur.station] = [];
          if(i>0){
            const prev = line.stops[i - 1];

            // prev -> cur
            network[prev.station].push({
              to: cur.station,
              line: line.id,
              platformFrom: prev.platform,
              platformTo: cur.platform
            });

            // cur -> prev
            network[cur.station].push({
              to: prev.station,
              line: line.id,
              platformFrom: cur.platform,
              platformTo: prev.platform
            });
          }
        }
      }

      renderLineOverview(data.lines);
    }

    function renderLineOverview(lines){
      const groups = {};
      for(const l of lines){
        const prefix = (l.id.match(/^[A-Z]+/) || ["X"])[0];
        if(!groups[prefix]) groups[prefix] = [];
        groups[prefix].push(l);
      }
      const div = document.getElementById('lineOverview');
      div.innerHTML = '';
      for(const prefix in groups){
        const g = document.createElement('div');
        g.className = 'line-group';
        g.innerHTML = `<h4>ðŸš‰ ${prefix}-Linien</h4><ul>${groups[prefix]
          .map(l => `<li><b>${l.name}</b>: ${l.stops.map(s => s.station).join(' â†’ ')}</li>`)
          .join('')}</ul>`;
        g.querySelector('h4').onclick = () => g.classList.toggle('open');
        div.appendChild(g);
      }
    }

    // Dijkstra auf State: (station, currentLine, usedM)
    function dijkstra(start, end, { transferWeight=1000, requireMetronom=false, forbidMetronom=false } = {}) {
      const dist = new Map();
      const prev = new Map();
      const pq = [];

      function key(station, line, usedM) { return station + "||" + (line||"") + "||" + (usedM?1:0); }

      const startKey = key(start, null, false);
      dist.set(startKey, { cost: 0, transfers: 0, steps: 0 });
      pq.push({ station: start, line: null, usedM: false, cost: 0, transfers: 0, steps: 0 });

      function pushState(state){
        pq.push(state);
        pq.sort((a,b)=>a.cost-b.cost);
      }

      while(pq.length){
        const cur = pq.shift();
        const curKey = key(cur.station, cur.line, cur.usedM);
        const bestHere = dist.get(curKey);
        if(!bestHere || bestHere.cost !== cur.cost) continue;

        if(cur.station === end && (!requireMetronom || cur.usedM)){
          return { endKey: curKey, prev, dist };
        }

        for(const e of (network[cur.station] || [])){
          if(forbidMetronom && e.line === "M") continue;

          const nextLine = e.line;
          const nextUsedM = cur.usedM || (nextLine === "M");
          const transferInc = (cur.line && cur.line !== nextLine) ? 1 : 0;

          const nextTransfers = cur.transfers + transferInc;
          const nextSteps = cur.steps + 1;
          const nextCost = nextTransfers * transferWeight + nextSteps;

          const nKey = key(e.to, nextLine, nextUsedM);
          const old = dist.get(nKey);
          if(!old || nextCost < old.cost){
            dist.set(nKey, { cost: nextCost, transfers: nextTransfers, steps: nextSteps });
            prev.set(nKey, { fromKey: curKey, edge: e, line: nextLine, station: e.to, usedM: nextUsedM });
            pushState({ station: e.to, line: nextLine, usedM: nextUsedM, cost: nextCost, transfers: nextTransfers, steps: nextSteps });
          }
        }
      }
      return null;
    }

    function reconstruct(result){
      const { endKey, prev, dist } = result;
      const meta = dist.get(endKey);
      const pathEdges = [];

      let k = endKey;
      while(prev.has(k)){
        const p = prev.get(k);
        pathEdges.push({
          fromStation: p.fromKey.split("||")[0],
          toStation: p.station,
          line: p.edge.line,
          platformFrom: p.edge.platformFrom,
          platformTo: p.edge.platformTo
        });
        k = p.fromKey;
      }
      pathEdges.reverse();
      return { pathEdges, transfers: meta.transfers };
    }

    function segmentize(pathEdges){
      const segments = [];
      if(pathEdges.length === 0) return segments;

      let curLine = pathEdges[0].line;
      let segFrom = pathEdges[0].fromStation;
      let segEdges = [];

      for(const e of pathEdges){
        if(e.line !== curLine){
          segments.push({ line: curLine, edges: segEdges, from: segFrom, to: segEdges[segEdges.length-1].toStation });
          curLine = e.line;
          segFrom = e.fromStation;
          segEdges = [e];
        } else {
          segEdges.push(e);
        }
      }
      segments.push({ line: curLine, edges: segEdges, from: segFrom, to: segEdges[segEdges.length-1].toStation });
      return segments;
    }

    function renderRoute(out, title, subtitle, route, showDivider=false){
      const segments = segmentize(route.pathEdges);

      out.innerHTML += `<div class="route-block">`;
      out.innerHTML += `<div class="route-title">${title}</div>`;
      if(subtitle) out.innerHTML += `<div class="route-subtitle">${subtitle}</div>`;

      for(const s of segments){
        const first = s.edges[0];
        const last = s.edges[s.edges.length-1];
        const mids = s.edges.slice(0,-1).map(x=>x.toStation);

        out.innerHTML += `<div class="route-segment" style="border-color:${lineColors[s.line] || '#999'}">`;
        out.innerHTML += `<div class="segment-line" style="background:${lineColors[s.line] || '#999'}">${s.line}</div>`;
        out.innerHTML += `<div class="main-stop">${s.from} (Gleis ${first.platformFrom}) â†’ ${s.to} (Gleis ${last.platformTo})</div>`;
        if(mids.length > 0){
          out.innerHTML += `<div class="intermediate">Zwischenhalte: ${mids.join(', ')}</div>`;
        }
        out.innerHTML += `</div>`;
      }

      out.innerHTML += `<p><b>Umstiege:</b> ${route.transfers}</p>`;
      out.innerHTML += `</div>`;
      if(showDivider) out.innerHTML += `<div class="divider"></div>`;
    }

    // Standard: OHNE Metronom; Alternative: MIT Metronom
    // Wenn Standard keine Route findet -> Metronom wird automatisch "Empfohlen"
    function findRoute(forceMinTransfers=false){
      const start = findStation(document.getElementById('startStation').value.trim());
      const end = findStation(document.getElementById('endStation').value.trim());
      const out = document.getElementById('output');

      if(!start || !end){
        out.innerHTML = '<p>UngÃ¼ltige Station(en)!</p>';
        return;
      }

      const mainRes = dijkstra(start, end, { transferWeight: 1000, requireMetronom: false, forbidMetronom: true });
      const mainRoute = mainRes ? reconstruct(mainRes) : null;

      const metroRes = dijkstra(start, end, { transferWeight: 1000, requireMetronom: true, forbidMetronom: false });
      const metroRoute = metroRes ? reconstruct(metroRes) : null;

      if(!mainRoute && !metroRoute){
        out.innerHTML = `<h3>Route von ${start} nach ${end}</h3><p>Keine Route gefunden!</p>`;
        return;
      }

      out.innerHTML = `<h3>Route von ${start} nach ${end}</h3>`;

      // Fall A: Standard gefunden
      if(mainRoute){
        renderRoute(out, "Empfohlen", "Standard (ohne Metronom)", mainRoute, !!metroRoute);
        if(metroRoute){
          renderRoute(out, "Alternative", "Mit Metronom (LB Ticket nicht GÃ¼ltig fÃ¼r Metronom)", metroRoute, false);
        }
        return;
      }

      // Fall B: Standard nicht verfÃ¼gbar -> Metronom als Empfohlen
      renderRoute(out, "Empfohlen", "Mit Metronom (da diese station nur von Metronom Gmbh angefahren wird)(LB Ticket nicht GÃ¼ltig)", metroRoute, false);
    }

    window.onload = loadLines;
  </script>
</body>
</html>
